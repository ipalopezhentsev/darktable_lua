"""
Generate the quality-test baseline session.

Runs dust detection (with reject collection) on all images in tests/images/
and writes the results to tests/baseline_session/ using the exact same format
as a regular debug session — so debug_ui.py can open it directly.

Run:
    conda run -n autocrop python auto_retouch/tests/generate_baseline.py

After running, commit the contents of auto_retouch/tests/baseline_session/.
"""

import os
import sys
import json
from pathlib import Path
from multiprocessing import Pool, cpu_count

# Put auto_retouch/ on the path so we can import detect_dust
TESTS_DIR = Path(__file__).parent
AUTO_RETOUCH_DIR = TESTS_DIR.parent
sys.path.insert(0, str(AUTO_RETOUCH_DIR))

import detect_dust

IMAGES_DIR = TESTS_DIR / "images"
BASELINE_DIR = TESTS_DIR / "baseline_session"


def _worker(image_path):
    """Run detection on one image; returns result tuple for write_debug_spots_json()."""
    stem = Path(image_path).stem
    img_path = str(image_path)

    import cv2
    img = cv2.imread(img_path)
    if img is None:
        return (stem, None, [], (0, 0), f"Failed to load: {img_path}", None)
    height, width = img.shape[:2]

    spots, rejected, error, local_std = detect_dust.detect_dust_spots(img_path, collect_rejects=True)
    return (stem, spots, rejected, (width, height), error, None)


def main():
    image_paths = sorted(IMAGES_DIR.glob("*.jpg")) + sorted(IMAGES_DIR.glob("*.jpeg"))
    if not image_paths:
        print(f"No images found in {IMAGES_DIR}")
        sys.exit(1)

    print(f"Found {len(image_paths)} image(s) in {IMAGES_DIR}")
    print(f"Output: {BASELINE_DIR}")
    BASELINE_DIR.mkdir(parents=True, exist_ok=True)

    n_workers = min(cpu_count(), len(image_paths))
    print(f"Running detection with {n_workers} worker(s)...")

    with Pool(processes=n_workers) as pool:
        raw_results = pool.map(_worker, image_paths)

    # Sort deterministically
    raw_results.sort(key=lambda r: r[0])

    image_paths_by_stem = {Path(p).stem: str(p) for p in image_paths}

    # Write per-image {stem}_debug_spots.json files
    detect_dust.write_debug_spots_json(raw_results, image_paths_by_stem, str(BASELINE_DIR))

    # Write empty annotations.json per image (no human annotations yet)
    for stem in image_paths_by_stem:
        ann_path = BASELINE_DIR / f"{stem}_annotations.json"
        if not ann_path.exists():
            ann = {"stem": stem, "false_positives": [], "missed_dust": [],
                   "source_overrides": [], "radius_overrides": [], "radius_mismatches": []}
            with open(ann_path, "w") as f:
                json.dump(ann, f, indent=2)

    # Write a brief debug_report.txt summarising detection counts
    report_path = BASELINE_DIR / "debug_report.txt"
    constants = {k: v for k, v in vars(detect_dust).items()
                 if k.isupper() and isinstance(v, (int, float))}
    with open(report_path, "w") as f:
        f.write("Baseline debug report\n")
        f.write("Generated by: generate_baseline.py\n\n")
        f.write("Detection constants:\n")
        for k, v in sorted(constants.items()):
            f.write(f"  {k} = {v}\n")
        f.write("\nPer-image results:\n")
        total_spots = 0
        for stem, spots, rejected, img_dims, error, _xmp in raw_results:
            w, h = img_dims
            if error:
                f.write(f"  {stem}: ERROR — {error}\n")
            else:
                n = len(spots) if spots else 0
                total_spots += n
                f.write(f"  {stem} ({w}x{h}): {n} spots detected\n")
        f.write(f"\nTotal: {total_spots} spots across {len(raw_results)} images\n")

    # Print summary
    print("\nResults:")
    errors = 0
    total = 0
    for stem, spots, rejected, img_dims, error, _xmp in raw_results:
        if error:
            print(f"  ERROR  {stem}: {error}")
            errors += 1
        else:
            n = len(spots) if spots else 0
            total += n
            print(f"  {stem}: {n} spots")
    print(f"\nBaseline written to: {BASELINE_DIR}")
    print(f"Total: {total} spots across {len(raw_results) - errors} images ({errors} errors)")
    if errors:
        sys.exit(1)


if __name__ == "__main__":
    main()
